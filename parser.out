Grammar:

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> statement
Rule 3     statements -> statements statement
Rule 4     statement -> for_stmt
Rule 5     statement -> if_stmt
Rule 6     statement -> cat_stmt
Rule 7     statement -> print_stmt
Rule 8     statement -> assign
Rule 9     assign -> ID ATRIB expr
Rule 10    expr -> ID ( expr_list )
Rule 11    expr -> expr / expr  [precedence=left, level=5]
Rule 12    expr -> expr * expr  [precedence=left, level=5]
Rule 13    expr -> expr - expr  [precedence=left, level=4]
Rule 14    expr -> expr + expr  [precedence=left, level=4]
Rule 15    expr -> ID
Rule 16    expr -> STRING
Rule 17    expr -> NUMBER
Rule 18    cat_stmt -> CAT ( expr )
Rule 19    print_stmt -> PRINT ( expr )
Rule 20    if_stmt -> IF ( condition ) { statements } ELSE { statements }
Rule 21    if_stmt -> IF ( condition ) { statements }
Rule 22    for_stmt -> FOR ( ID IN expr ) { statements }
Rule 23    condition -> condition OR condition  [precedence=left, level=1]
Rule 24    condition -> condition AND condition  [precedence=left, level=2]
Rule 25    condition -> expr NE expr  [precedence=left, level=3]
Rule 26    condition -> expr EQ expr  [precedence=left, level=3]
Rule 27    condition -> expr LE expr  [precedence=left, level=3]
Rule 28    condition -> expr GE expr  [precedence=left, level=3]
Rule 29    condition -> expr LT expr  [precedence=left, level=3]
Rule 30    condition -> expr GT expr  [precedence=left, level=3]
Rule 31    expr_list -> expr , expr_list
Rule 32    expr_list -> expr

Terminals, with rules where they appear:

(                    : 10 18 19 20 21 22
)                    : 10 18 19 20 21 22
*                    : 12
+                    : 14
,                    : 31
-                    : 13
/                    : 11
AND                  : 24
ATRIB                : 9
CAT                  : 18
ELSE                 : 20
EQ                   : 26
FOR                  : 22
GE                   : 28
GT                   : 30
ID                   : 9 10 15 22
IF                   : 20 21
IN                   : 22
LE                   : 27
LT                   : 29
NE                   : 25
NUMBER               : 17
OR                   : 23
PRINT                : 19
STRING               : 16
error                : 
{                    : 20 20 21 22
}                    : 20 20 21 22

Nonterminals, with rules where they appear:

assign               : 8
cat_stmt             : 6
condition            : 20 21 23 23 24 24
expr                 : 9 11 11 12 12 13 13 14 14 18 19 22 25 25 26 26 27 27 28 28 29 29 30 30 31 32
expr_list            : 10 31
for_stmt             : 4
if_stmt              : 5
print_stmt           : 7
program              : 0
statement            : 2 3
statements           : 1 3 20 20 21 22


state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . for_stmt
    (5) statement -> . if_stmt
    (6) statement -> . cat_stmt
    (7) statement -> . print_stmt
    (8) statement -> . assign
    (22) for_stmt -> . FOR ( ID IN expr ) { statements }
    (20) if_stmt -> . IF ( condition ) { statements } ELSE { statements }
    (21) if_stmt -> . IF ( condition ) { statements }
    (18) cat_stmt -> . CAT ( expr )
    (19) print_stmt -> . PRINT ( expr )
    (9) assign -> . ID ATRIB expr
    FOR             shift and go to state 9
    IF              shift and go to state 11
    CAT             shift and go to state 12
    PRINT           shift and go to state 13
    ID              shift and go to state 10

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    for_stmt                       shift and go to state 4
    if_stmt                        shift and go to state 5
    cat_stmt                       shift and go to state 6
    print_stmt                     shift and go to state 7
    assign                         shift and go to state 8

state 1

    (0) S' -> program .


state 2

    (1) program -> statements .
    (3) statements -> statements . statement
    (4) statement -> . for_stmt
    (5) statement -> . if_stmt
    (6) statement -> . cat_stmt
    (7) statement -> . print_stmt
    (8) statement -> . assign
    (22) for_stmt -> . FOR ( ID IN expr ) { statements }
    (20) if_stmt -> . IF ( condition ) { statements } ELSE { statements }
    (21) if_stmt -> . IF ( condition ) { statements }
    (18) cat_stmt -> . CAT ( expr )
    (19) print_stmt -> . PRINT ( expr )
    (9) assign -> . ID ATRIB expr
    $end            reduce using rule 1 (program -> statements .)
    FOR             shift and go to state 9
    IF              shift and go to state 11
    CAT             shift and go to state 12
    PRINT           shift and go to state 13
    ID              shift and go to state 10

    statement                      shift and go to state 14
    for_stmt                       shift and go to state 4
    if_stmt                        shift and go to state 5
    cat_stmt                       shift and go to state 6
    print_stmt                     shift and go to state 7
    assign                         shift and go to state 8

state 3

    (2) statements -> statement .
    FOR             reduce using rule 2 (statements -> statement .)
    IF              reduce using rule 2 (statements -> statement .)
    CAT             reduce using rule 2 (statements -> statement .)
    PRINT           reduce using rule 2 (statements -> statement .)
    ID              reduce using rule 2 (statements -> statement .)
    $end            reduce using rule 2 (statements -> statement .)
    }               reduce using rule 2 (statements -> statement .)


state 4

    (4) statement -> for_stmt .
    FOR             reduce using rule 4 (statement -> for_stmt .)
    IF              reduce using rule 4 (statement -> for_stmt .)
    CAT             reduce using rule 4 (statement -> for_stmt .)
    PRINT           reduce using rule 4 (statement -> for_stmt .)
    ID              reduce using rule 4 (statement -> for_stmt .)
    $end            reduce using rule 4 (statement -> for_stmt .)
    }               reduce using rule 4 (statement -> for_stmt .)


state 5

    (5) statement -> if_stmt .
    FOR             reduce using rule 5 (statement -> if_stmt .)
    IF              reduce using rule 5 (statement -> if_stmt .)
    CAT             reduce using rule 5 (statement -> if_stmt .)
    PRINT           reduce using rule 5 (statement -> if_stmt .)
    ID              reduce using rule 5 (statement -> if_stmt .)
    $end            reduce using rule 5 (statement -> if_stmt .)
    }               reduce using rule 5 (statement -> if_stmt .)


state 6

    (6) statement -> cat_stmt .
    FOR             reduce using rule 6 (statement -> cat_stmt .)
    IF              reduce using rule 6 (statement -> cat_stmt .)
    CAT             reduce using rule 6 (statement -> cat_stmt .)
    PRINT           reduce using rule 6 (statement -> cat_stmt .)
    ID              reduce using rule 6 (statement -> cat_stmt .)
    $end            reduce using rule 6 (statement -> cat_stmt .)
    }               reduce using rule 6 (statement -> cat_stmt .)


state 7

    (7) statement -> print_stmt .
    FOR             reduce using rule 7 (statement -> print_stmt .)
    IF              reduce using rule 7 (statement -> print_stmt .)
    CAT             reduce using rule 7 (statement -> print_stmt .)
    PRINT           reduce using rule 7 (statement -> print_stmt .)
    ID              reduce using rule 7 (statement -> print_stmt .)
    $end            reduce using rule 7 (statement -> print_stmt .)
    }               reduce using rule 7 (statement -> print_stmt .)


state 8

    (8) statement -> assign .
    FOR             reduce using rule 8 (statement -> assign .)
    IF              reduce using rule 8 (statement -> assign .)
    CAT             reduce using rule 8 (statement -> assign .)
    PRINT           reduce using rule 8 (statement -> assign .)
    ID              reduce using rule 8 (statement -> assign .)
    $end            reduce using rule 8 (statement -> assign .)
    }               reduce using rule 8 (statement -> assign .)


state 9

    (22) for_stmt -> FOR . ( ID IN expr ) { statements }
    (               shift and go to state 15


state 10

    (9) assign -> ID . ATRIB expr
    ATRIB           shift and go to state 16


state 11

    (20) if_stmt -> IF . ( condition ) { statements } ELSE { statements }
    (21) if_stmt -> IF . ( condition ) { statements }
    (               shift and go to state 17


state 12

    (18) cat_stmt -> CAT . ( expr )
    (               shift and go to state 18


state 13

    (19) print_stmt -> PRINT . ( expr )
    (               shift and go to state 19


state 14

    (3) statements -> statements statement .
    FOR             reduce using rule 3 (statements -> statements statement .)
    IF              reduce using rule 3 (statements -> statements statement .)
    CAT             reduce using rule 3 (statements -> statements statement .)
    PRINT           reduce using rule 3 (statements -> statements statement .)
    ID              reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)
    }               reduce using rule 3 (statements -> statements statement .)


state 15

    (22) for_stmt -> FOR ( . ID IN expr ) { statements }
    ID              shift and go to state 20


state 16

    (9) assign -> ID ATRIB . expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 22

state 17

    (20) if_stmt -> IF ( . condition ) { statements } ELSE { statements }
    (21) if_stmt -> IF ( . condition ) { statements }
    (23) condition -> . condition OR condition
    (24) condition -> . condition AND condition
    (25) condition -> . expr NE expr
    (26) condition -> . expr EQ expr
    (27) condition -> . expr LE expr
    (28) condition -> . expr GE expr
    (29) condition -> . expr LT expr
    (30) condition -> . expr GT expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    condition                      shift and go to state 25
    expr                           shift and go to state 26

state 18

    (18) cat_stmt -> CAT ( . expr )
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 27

state 19

    (19) print_stmt -> PRINT ( . expr )
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 28

state 20

    (22) for_stmt -> FOR ( ID . IN expr ) { statements }
    IN              shift and go to state 29


state 21

    (10) expr -> ID . ( expr_list )
    (15) expr -> ID .
    (               shift and go to state 30
    /               reduce using rule 15 (expr -> ID .)
    *               reduce using rule 15 (expr -> ID .)
    -               reduce using rule 15 (expr -> ID .)
    +               reduce using rule 15 (expr -> ID .)
    FOR             reduce using rule 15 (expr -> ID .)
    IF              reduce using rule 15 (expr -> ID .)
    CAT             reduce using rule 15 (expr -> ID .)
    PRINT           reduce using rule 15 (expr -> ID .)
    ID              reduce using rule 15 (expr -> ID .)
    $end            reduce using rule 15 (expr -> ID .)
    }               reduce using rule 15 (expr -> ID .)
    NE              reduce using rule 15 (expr -> ID .)
    EQ              reduce using rule 15 (expr -> ID .)
    LE              reduce using rule 15 (expr -> ID .)
    GE              reduce using rule 15 (expr -> ID .)
    LT              reduce using rule 15 (expr -> ID .)
    GT              reduce using rule 15 (expr -> ID .)
    )               reduce using rule 15 (expr -> ID .)
    ,               reduce using rule 15 (expr -> ID .)
    OR              reduce using rule 15 (expr -> ID .)
    AND             reduce using rule 15 (expr -> ID .)


state 22

    (9) assign -> ID ATRIB expr .
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    FOR             reduce using rule 9 (assign -> ID ATRIB expr .)
    IF              reduce using rule 9 (assign -> ID ATRIB expr .)
    CAT             reduce using rule 9 (assign -> ID ATRIB expr .)
    PRINT           reduce using rule 9 (assign -> ID ATRIB expr .)
    ID              reduce using rule 9 (assign -> ID ATRIB expr .)
    $end            reduce using rule 9 (assign -> ID ATRIB expr .)
    }               reduce using rule 9 (assign -> ID ATRIB expr .)
    /               shift and go to state 31
    *               shift and go to state 32
    -               shift and go to state 33
    +               shift and go to state 34


state 23

    (16) expr -> STRING .
    /               reduce using rule 16 (expr -> STRING .)
    *               reduce using rule 16 (expr -> STRING .)
    -               reduce using rule 16 (expr -> STRING .)
    +               reduce using rule 16 (expr -> STRING .)
    FOR             reduce using rule 16 (expr -> STRING .)
    IF              reduce using rule 16 (expr -> STRING .)
    CAT             reduce using rule 16 (expr -> STRING .)
    PRINT           reduce using rule 16 (expr -> STRING .)
    ID              reduce using rule 16 (expr -> STRING .)
    $end            reduce using rule 16 (expr -> STRING .)
    }               reduce using rule 16 (expr -> STRING .)
    NE              reduce using rule 16 (expr -> STRING .)
    EQ              reduce using rule 16 (expr -> STRING .)
    LE              reduce using rule 16 (expr -> STRING .)
    GE              reduce using rule 16 (expr -> STRING .)
    LT              reduce using rule 16 (expr -> STRING .)
    GT              reduce using rule 16 (expr -> STRING .)
    )               reduce using rule 16 (expr -> STRING .)
    ,               reduce using rule 16 (expr -> STRING .)
    OR              reduce using rule 16 (expr -> STRING .)
    AND             reduce using rule 16 (expr -> STRING .)


state 24

    (17) expr -> NUMBER .
    /               reduce using rule 17 (expr -> NUMBER .)
    *               reduce using rule 17 (expr -> NUMBER .)
    -               reduce using rule 17 (expr -> NUMBER .)
    +               reduce using rule 17 (expr -> NUMBER .)
    FOR             reduce using rule 17 (expr -> NUMBER .)
    IF              reduce using rule 17 (expr -> NUMBER .)
    CAT             reduce using rule 17 (expr -> NUMBER .)
    PRINT           reduce using rule 17 (expr -> NUMBER .)
    ID              reduce using rule 17 (expr -> NUMBER .)
    $end            reduce using rule 17 (expr -> NUMBER .)
    }               reduce using rule 17 (expr -> NUMBER .)
    NE              reduce using rule 17 (expr -> NUMBER .)
    EQ              reduce using rule 17 (expr -> NUMBER .)
    LE              reduce using rule 17 (expr -> NUMBER .)
    GE              reduce using rule 17 (expr -> NUMBER .)
    LT              reduce using rule 17 (expr -> NUMBER .)
    GT              reduce using rule 17 (expr -> NUMBER .)
    )               reduce using rule 17 (expr -> NUMBER .)
    ,               reduce using rule 17 (expr -> NUMBER .)
    OR              reduce using rule 17 (expr -> NUMBER .)
    AND             reduce using rule 17 (expr -> NUMBER .)


state 25

    (20) if_stmt -> IF ( condition . ) { statements } ELSE { statements }
    (21) if_stmt -> IF ( condition . ) { statements }
    (23) condition -> condition . OR condition
    (24) condition -> condition . AND condition
    )               shift and go to state 35
    OR              shift and go to state 36
    AND             shift and go to state 37


state 26

    (25) condition -> expr . NE expr
    (26) condition -> expr . EQ expr
    (27) condition -> expr . LE expr
    (28) condition -> expr . GE expr
    (29) condition -> expr . LT expr
    (30) condition -> expr . GT expr
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    NE              shift and go to state 38
    EQ              shift and go to state 39
    LE              shift and go to state 40
    GE              shift and go to state 41
    LT              shift and go to state 42
    GT              shift and go to state 43
    /               shift and go to state 31
    *               shift and go to state 32
    -               shift and go to state 33
    +               shift and go to state 34


state 27

    (18) cat_stmt -> CAT ( expr . )
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    )               shift and go to state 44
    /               shift and go to state 31
    *               shift and go to state 32
    -               shift and go to state 33
    +               shift and go to state 34


state 28

    (19) print_stmt -> PRINT ( expr . )
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    )               shift and go to state 45
    /               shift and go to state 31
    *               shift and go to state 32
    -               shift and go to state 33
    +               shift and go to state 34


state 29

    (22) for_stmt -> FOR ( ID IN . expr ) { statements }
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 46

state 30

    (10) expr -> ID ( . expr_list )
    (31) expr_list -> . expr , expr_list
    (32) expr_list -> . expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr_list                      shift and go to state 47
    expr                           shift and go to state 48

state 31

    (11) expr -> expr / . expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 49

state 32

    (12) expr -> expr * . expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 50

state 33

    (13) expr -> expr - . expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 51

state 34

    (14) expr -> expr + . expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 52

state 35

    (20) if_stmt -> IF ( condition ) . { statements } ELSE { statements }
    (21) if_stmt -> IF ( condition ) . { statements }
    {               shift and go to state 53


state 36

    (23) condition -> condition OR . condition
    (23) condition -> . condition OR condition
    (24) condition -> . condition AND condition
    (25) condition -> . expr NE expr
    (26) condition -> . expr EQ expr
    (27) condition -> . expr LE expr
    (28) condition -> . expr GE expr
    (29) condition -> . expr LT expr
    (30) condition -> . expr GT expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    condition                      shift and go to state 54
    expr                           shift and go to state 26

state 37

    (24) condition -> condition AND . condition
    (23) condition -> . condition OR condition
    (24) condition -> . condition AND condition
    (25) condition -> . expr NE expr
    (26) condition -> . expr EQ expr
    (27) condition -> . expr LE expr
    (28) condition -> . expr GE expr
    (29) condition -> . expr LT expr
    (30) condition -> . expr GT expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    condition                      shift and go to state 55
    expr                           shift and go to state 26

state 38

    (25) condition -> expr NE . expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 56

state 39

    (26) condition -> expr EQ . expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 57

state 40

    (27) condition -> expr LE . expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 58

state 41

    (28) condition -> expr GE . expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 59

state 42

    (29) condition -> expr LT . expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 60

state 43

    (30) condition -> expr GT . expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 61

state 44

    (18) cat_stmt -> CAT ( expr ) .
    FOR             reduce using rule 18 (cat_stmt -> CAT ( expr ) .)
    IF              reduce using rule 18 (cat_stmt -> CAT ( expr ) .)
    CAT             reduce using rule 18 (cat_stmt -> CAT ( expr ) .)
    PRINT           reduce using rule 18 (cat_stmt -> CAT ( expr ) .)
    ID              reduce using rule 18 (cat_stmt -> CAT ( expr ) .)
    $end            reduce using rule 18 (cat_stmt -> CAT ( expr ) .)
    }               reduce using rule 18 (cat_stmt -> CAT ( expr ) .)


state 45

    (19) print_stmt -> PRINT ( expr ) .
    FOR             reduce using rule 19 (print_stmt -> PRINT ( expr ) .)
    IF              reduce using rule 19 (print_stmt -> PRINT ( expr ) .)
    CAT             reduce using rule 19 (print_stmt -> PRINT ( expr ) .)
    PRINT           reduce using rule 19 (print_stmt -> PRINT ( expr ) .)
    ID              reduce using rule 19 (print_stmt -> PRINT ( expr ) .)
    $end            reduce using rule 19 (print_stmt -> PRINT ( expr ) .)
    }               reduce using rule 19 (print_stmt -> PRINT ( expr ) .)


state 46

    (22) for_stmt -> FOR ( ID IN expr . ) { statements }
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    )               shift and go to state 62
    /               shift and go to state 31
    *               shift and go to state 32
    -               shift and go to state 33
    +               shift and go to state 34


state 47

    (10) expr -> ID ( expr_list . )
    )               shift and go to state 63


state 48

    (31) expr_list -> expr . , expr_list
    (32) expr_list -> expr .
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    ,               shift and go to state 64
    )               reduce using rule 32 (expr_list -> expr .)
    /               shift and go to state 31
    *               shift and go to state 32
    -               shift and go to state 33
    +               shift and go to state 34


state 49

    (11) expr -> expr / expr .
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    /               reduce using rule 11 (expr -> expr / expr .)
    *               reduce using rule 11 (expr -> expr / expr .)
    -               reduce using rule 11 (expr -> expr / expr .)
    +               reduce using rule 11 (expr -> expr / expr .)
    FOR             reduce using rule 11 (expr -> expr / expr .)
    IF              reduce using rule 11 (expr -> expr / expr .)
    CAT             reduce using rule 11 (expr -> expr / expr .)
    PRINT           reduce using rule 11 (expr -> expr / expr .)
    ID              reduce using rule 11 (expr -> expr / expr .)
    $end            reduce using rule 11 (expr -> expr / expr .)
    }               reduce using rule 11 (expr -> expr / expr .)
    NE              reduce using rule 11 (expr -> expr / expr .)
    EQ              reduce using rule 11 (expr -> expr / expr .)
    LE              reduce using rule 11 (expr -> expr / expr .)
    GE              reduce using rule 11 (expr -> expr / expr .)
    LT              reduce using rule 11 (expr -> expr / expr .)
    GT              reduce using rule 11 (expr -> expr / expr .)
    )               reduce using rule 11 (expr -> expr / expr .)
    ,               reduce using rule 11 (expr -> expr / expr .)
    OR              reduce using rule 11 (expr -> expr / expr .)
    AND             reduce using rule 11 (expr -> expr / expr .)


state 50

    (12) expr -> expr * expr .
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    /               reduce using rule 12 (expr -> expr * expr .)
    *               reduce using rule 12 (expr -> expr * expr .)
    -               reduce using rule 12 (expr -> expr * expr .)
    +               reduce using rule 12 (expr -> expr * expr .)
    FOR             reduce using rule 12 (expr -> expr * expr .)
    IF              reduce using rule 12 (expr -> expr * expr .)
    CAT             reduce using rule 12 (expr -> expr * expr .)
    PRINT           reduce using rule 12 (expr -> expr * expr .)
    ID              reduce using rule 12 (expr -> expr * expr .)
    $end            reduce using rule 12 (expr -> expr * expr .)
    }               reduce using rule 12 (expr -> expr * expr .)
    NE              reduce using rule 12 (expr -> expr * expr .)
    EQ              reduce using rule 12 (expr -> expr * expr .)
    LE              reduce using rule 12 (expr -> expr * expr .)
    GE              reduce using rule 12 (expr -> expr * expr .)
    LT              reduce using rule 12 (expr -> expr * expr .)
    GT              reduce using rule 12 (expr -> expr * expr .)
    )               reduce using rule 12 (expr -> expr * expr .)
    ,               reduce using rule 12 (expr -> expr * expr .)
    OR              reduce using rule 12 (expr -> expr * expr .)
    AND             reduce using rule 12 (expr -> expr * expr .)


state 51

    (13) expr -> expr - expr .
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    -               reduce using rule 13 (expr -> expr - expr .)
    +               reduce using rule 13 (expr -> expr - expr .)
    FOR             reduce using rule 13 (expr -> expr - expr .)
    IF              reduce using rule 13 (expr -> expr - expr .)
    CAT             reduce using rule 13 (expr -> expr - expr .)
    PRINT           reduce using rule 13 (expr -> expr - expr .)
    ID              reduce using rule 13 (expr -> expr - expr .)
    $end            reduce using rule 13 (expr -> expr - expr .)
    }               reduce using rule 13 (expr -> expr - expr .)
    NE              reduce using rule 13 (expr -> expr - expr .)
    EQ              reduce using rule 13 (expr -> expr - expr .)
    LE              reduce using rule 13 (expr -> expr - expr .)
    GE              reduce using rule 13 (expr -> expr - expr .)
    LT              reduce using rule 13 (expr -> expr - expr .)
    GT              reduce using rule 13 (expr -> expr - expr .)
    )               reduce using rule 13 (expr -> expr - expr .)
    ,               reduce using rule 13 (expr -> expr - expr .)
    OR              reduce using rule 13 (expr -> expr - expr .)
    AND             reduce using rule 13 (expr -> expr - expr .)
    /               shift and go to state 31
    *               shift and go to state 32


state 52

    (14) expr -> expr + expr .
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    -               reduce using rule 14 (expr -> expr + expr .)
    +               reduce using rule 14 (expr -> expr + expr .)
    FOR             reduce using rule 14 (expr -> expr + expr .)
    IF              reduce using rule 14 (expr -> expr + expr .)
    CAT             reduce using rule 14 (expr -> expr + expr .)
    PRINT           reduce using rule 14 (expr -> expr + expr .)
    ID              reduce using rule 14 (expr -> expr + expr .)
    $end            reduce using rule 14 (expr -> expr + expr .)
    }               reduce using rule 14 (expr -> expr + expr .)
    NE              reduce using rule 14 (expr -> expr + expr .)
    EQ              reduce using rule 14 (expr -> expr + expr .)
    LE              reduce using rule 14 (expr -> expr + expr .)
    GE              reduce using rule 14 (expr -> expr + expr .)
    LT              reduce using rule 14 (expr -> expr + expr .)
    GT              reduce using rule 14 (expr -> expr + expr .)
    )               reduce using rule 14 (expr -> expr + expr .)
    ,               reduce using rule 14 (expr -> expr + expr .)
    OR              reduce using rule 14 (expr -> expr + expr .)
    AND             reduce using rule 14 (expr -> expr + expr .)
    /               shift and go to state 31
    *               shift and go to state 32


state 53

    (20) if_stmt -> IF ( condition ) { . statements } ELSE { statements }
    (21) if_stmt -> IF ( condition ) { . statements }
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . for_stmt
    (5) statement -> . if_stmt
    (6) statement -> . cat_stmt
    (7) statement -> . print_stmt
    (8) statement -> . assign
    (22) for_stmt -> . FOR ( ID IN expr ) { statements }
    (20) if_stmt -> . IF ( condition ) { statements } ELSE { statements }
    (21) if_stmt -> . IF ( condition ) { statements }
    (18) cat_stmt -> . CAT ( expr )
    (19) print_stmt -> . PRINT ( expr )
    (9) assign -> . ID ATRIB expr
    FOR             shift and go to state 9
    IF              shift and go to state 11
    CAT             shift and go to state 12
    PRINT           shift and go to state 13
    ID              shift and go to state 10

    statements                     shift and go to state 65
    statement                      shift and go to state 3
    for_stmt                       shift and go to state 4
    if_stmt                        shift and go to state 5
    cat_stmt                       shift and go to state 6
    print_stmt                     shift and go to state 7
    assign                         shift and go to state 8

state 54

    (23) condition -> condition OR condition .
    (23) condition -> condition . OR condition
    (24) condition -> condition . AND condition
    )               reduce using rule 23 (condition -> condition OR condition .)
    OR              reduce using rule 23 (condition -> condition OR condition .)
    AND             shift and go to state 37


state 55

    (24) condition -> condition AND condition .
    (23) condition -> condition . OR condition
    (24) condition -> condition . AND condition
    )               reduce using rule 24 (condition -> condition AND condition .)
    OR              reduce using rule 24 (condition -> condition AND condition .)
    AND             reduce using rule 24 (condition -> condition AND condition .)


state 56

    (25) condition -> expr NE expr .
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    )               reduce using rule 25 (condition -> expr NE expr .)
    OR              reduce using rule 25 (condition -> expr NE expr .)
    AND             reduce using rule 25 (condition -> expr NE expr .)
    /               shift and go to state 31
    *               shift and go to state 32
    -               shift and go to state 33
    +               shift and go to state 34


state 57

    (26) condition -> expr EQ expr .
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    )               reduce using rule 26 (condition -> expr EQ expr .)
    OR              reduce using rule 26 (condition -> expr EQ expr .)
    AND             reduce using rule 26 (condition -> expr EQ expr .)
    /               shift and go to state 31
    *               shift and go to state 32
    -               shift and go to state 33
    +               shift and go to state 34


state 58

    (27) condition -> expr LE expr .
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    )               reduce using rule 27 (condition -> expr LE expr .)
    OR              reduce using rule 27 (condition -> expr LE expr .)
    AND             reduce using rule 27 (condition -> expr LE expr .)
    /               shift and go to state 31
    *               shift and go to state 32
    -               shift and go to state 33
    +               shift and go to state 34


state 59

    (28) condition -> expr GE expr .
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    )               reduce using rule 28 (condition -> expr GE expr .)
    OR              reduce using rule 28 (condition -> expr GE expr .)
    AND             reduce using rule 28 (condition -> expr GE expr .)
    /               shift and go to state 31
    *               shift and go to state 32
    -               shift and go to state 33
    +               shift and go to state 34


state 60

    (29) condition -> expr LT expr .
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    )               reduce using rule 29 (condition -> expr LT expr .)
    OR              reduce using rule 29 (condition -> expr LT expr .)
    AND             reduce using rule 29 (condition -> expr LT expr .)
    /               shift and go to state 31
    *               shift and go to state 32
    -               shift and go to state 33
    +               shift and go to state 34


state 61

    (30) condition -> expr GT expr .
    (11) expr -> expr . / expr
    (12) expr -> expr . * expr
    (13) expr -> expr . - expr
    (14) expr -> expr . + expr
    )               reduce using rule 30 (condition -> expr GT expr .)
    OR              reduce using rule 30 (condition -> expr GT expr .)
    AND             reduce using rule 30 (condition -> expr GT expr .)
    /               shift and go to state 31
    *               shift and go to state 32
    -               shift and go to state 33
    +               shift and go to state 34


state 62

    (22) for_stmt -> FOR ( ID IN expr ) . { statements }
    {               shift and go to state 66


state 63

    (10) expr -> ID ( expr_list ) .
    /               reduce using rule 10 (expr -> ID ( expr_list ) .)
    *               reduce using rule 10 (expr -> ID ( expr_list ) .)
    -               reduce using rule 10 (expr -> ID ( expr_list ) .)
    +               reduce using rule 10 (expr -> ID ( expr_list ) .)
    FOR             reduce using rule 10 (expr -> ID ( expr_list ) .)
    IF              reduce using rule 10 (expr -> ID ( expr_list ) .)
    CAT             reduce using rule 10 (expr -> ID ( expr_list ) .)
    PRINT           reduce using rule 10 (expr -> ID ( expr_list ) .)
    ID              reduce using rule 10 (expr -> ID ( expr_list ) .)
    $end            reduce using rule 10 (expr -> ID ( expr_list ) .)
    }               reduce using rule 10 (expr -> ID ( expr_list ) .)
    NE              reduce using rule 10 (expr -> ID ( expr_list ) .)
    EQ              reduce using rule 10 (expr -> ID ( expr_list ) .)
    LE              reduce using rule 10 (expr -> ID ( expr_list ) .)
    GE              reduce using rule 10 (expr -> ID ( expr_list ) .)
    LT              reduce using rule 10 (expr -> ID ( expr_list ) .)
    GT              reduce using rule 10 (expr -> ID ( expr_list ) .)
    )               reduce using rule 10 (expr -> ID ( expr_list ) .)
    ,               reduce using rule 10 (expr -> ID ( expr_list ) .)
    OR              reduce using rule 10 (expr -> ID ( expr_list ) .)
    AND             reduce using rule 10 (expr -> ID ( expr_list ) .)


state 64

    (31) expr_list -> expr , . expr_list
    (31) expr_list -> . expr , expr_list
    (32) expr_list -> . expr
    (10) expr -> . ID ( expr_list )
    (11) expr -> . expr / expr
    (12) expr -> . expr * expr
    (13) expr -> . expr - expr
    (14) expr -> . expr + expr
    (15) expr -> . ID
    (16) expr -> . STRING
    (17) expr -> . NUMBER
    ID              shift and go to state 21
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24

    expr                           shift and go to state 48
    expr_list                      shift and go to state 67

state 65

    (20) if_stmt -> IF ( condition ) { statements . } ELSE { statements }
    (21) if_stmt -> IF ( condition ) { statements . }
    (3) statements -> statements . statement
    (4) statement -> . for_stmt
    (5) statement -> . if_stmt
    (6) statement -> . cat_stmt
    (7) statement -> . print_stmt
    (8) statement -> . assign
    (22) for_stmt -> . FOR ( ID IN expr ) { statements }
    (20) if_stmt -> . IF ( condition ) { statements } ELSE { statements }
    (21) if_stmt -> . IF ( condition ) { statements }
    (18) cat_stmt -> . CAT ( expr )
    (19) print_stmt -> . PRINT ( expr )
    (9) assign -> . ID ATRIB expr
    }               shift and go to state 68
    FOR             shift and go to state 9
    IF              shift and go to state 11
    CAT             shift and go to state 12
    PRINT           shift and go to state 13
    ID              shift and go to state 10

    statement                      shift and go to state 14
    for_stmt                       shift and go to state 4
    if_stmt                        shift and go to state 5
    cat_stmt                       shift and go to state 6
    print_stmt                     shift and go to state 7
    assign                         shift and go to state 8

state 66

    (22) for_stmt -> FOR ( ID IN expr ) { . statements }
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . for_stmt
    (5) statement -> . if_stmt
    (6) statement -> . cat_stmt
    (7) statement -> . print_stmt
    (8) statement -> . assign
    (22) for_stmt -> . FOR ( ID IN expr ) { statements }
    (20) if_stmt -> . IF ( condition ) { statements } ELSE { statements }
    (21) if_stmt -> . IF ( condition ) { statements }
    (18) cat_stmt -> . CAT ( expr )
    (19) print_stmt -> . PRINT ( expr )
    (9) assign -> . ID ATRIB expr
    FOR             shift and go to state 9
    IF              shift and go to state 11
    CAT             shift and go to state 12
    PRINT           shift and go to state 13
    ID              shift and go to state 10

    statements                     shift and go to state 69
    statement                      shift and go to state 3
    for_stmt                       shift and go to state 4
    if_stmt                        shift and go to state 5
    cat_stmt                       shift and go to state 6
    print_stmt                     shift and go to state 7
    assign                         shift and go to state 8

state 67

    (31) expr_list -> expr , expr_list .
    )               reduce using rule 31 (expr_list -> expr , expr_list .)


state 68

    (20) if_stmt -> IF ( condition ) { statements } . ELSE { statements }
    (21) if_stmt -> IF ( condition ) { statements } .
    ELSE            shift and go to state 70
    FOR             reduce using rule 21 (if_stmt -> IF ( condition ) { statements } .)
    IF              reduce using rule 21 (if_stmt -> IF ( condition ) { statements } .)
    CAT             reduce using rule 21 (if_stmt -> IF ( condition ) { statements } .)
    PRINT           reduce using rule 21 (if_stmt -> IF ( condition ) { statements } .)
    ID              reduce using rule 21 (if_stmt -> IF ( condition ) { statements } .)
    $end            reduce using rule 21 (if_stmt -> IF ( condition ) { statements } .)
    }               reduce using rule 21 (if_stmt -> IF ( condition ) { statements } .)


state 69

    (22) for_stmt -> FOR ( ID IN expr ) { statements . }
    (3) statements -> statements . statement
    (4) statement -> . for_stmt
    (5) statement -> . if_stmt
    (6) statement -> . cat_stmt
    (7) statement -> . print_stmt
    (8) statement -> . assign
    (22) for_stmt -> . FOR ( ID IN expr ) { statements }
    (20) if_stmt -> . IF ( condition ) { statements } ELSE { statements }
    (21) if_stmt -> . IF ( condition ) { statements }
    (18) cat_stmt -> . CAT ( expr )
    (19) print_stmt -> . PRINT ( expr )
    (9) assign -> . ID ATRIB expr
    }               shift and go to state 71
    FOR             shift and go to state 9
    IF              shift and go to state 11
    CAT             shift and go to state 12
    PRINT           shift and go to state 13
    ID              shift and go to state 10

    statement                      shift and go to state 14
    for_stmt                       shift and go to state 4
    if_stmt                        shift and go to state 5
    cat_stmt                       shift and go to state 6
    print_stmt                     shift and go to state 7
    assign                         shift and go to state 8

state 70

    (20) if_stmt -> IF ( condition ) { statements } ELSE . { statements }
    {               shift and go to state 72


state 71

    (22) for_stmt -> FOR ( ID IN expr ) { statements } .
    FOR             reduce using rule 22 (for_stmt -> FOR ( ID IN expr ) { statements } .)
    IF              reduce using rule 22 (for_stmt -> FOR ( ID IN expr ) { statements } .)
    CAT             reduce using rule 22 (for_stmt -> FOR ( ID IN expr ) { statements } .)
    PRINT           reduce using rule 22 (for_stmt -> FOR ( ID IN expr ) { statements } .)
    ID              reduce using rule 22 (for_stmt -> FOR ( ID IN expr ) { statements } .)
    $end            reduce using rule 22 (for_stmt -> FOR ( ID IN expr ) { statements } .)
    }               reduce using rule 22 (for_stmt -> FOR ( ID IN expr ) { statements } .)


state 72

    (20) if_stmt -> IF ( condition ) { statements } ELSE { . statements }
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . for_stmt
    (5) statement -> . if_stmt
    (6) statement -> . cat_stmt
    (7) statement -> . print_stmt
    (8) statement -> . assign
    (22) for_stmt -> . FOR ( ID IN expr ) { statements }
    (20) if_stmt -> . IF ( condition ) { statements } ELSE { statements }
    (21) if_stmt -> . IF ( condition ) { statements }
    (18) cat_stmt -> . CAT ( expr )
    (19) print_stmt -> . PRINT ( expr )
    (9) assign -> . ID ATRIB expr
    FOR             shift and go to state 9
    IF              shift and go to state 11
    CAT             shift and go to state 12
    PRINT           shift and go to state 13
    ID              shift and go to state 10

    statements                     shift and go to state 73
    statement                      shift and go to state 3
    for_stmt                       shift and go to state 4
    if_stmt                        shift and go to state 5
    cat_stmt                       shift and go to state 6
    print_stmt                     shift and go to state 7
    assign                         shift and go to state 8

state 73

    (20) if_stmt -> IF ( condition ) { statements } ELSE { statements . }
    (3) statements -> statements . statement
    (4) statement -> . for_stmt
    (5) statement -> . if_stmt
    (6) statement -> . cat_stmt
    (7) statement -> . print_stmt
    (8) statement -> . assign
    (22) for_stmt -> . FOR ( ID IN expr ) { statements }
    (20) if_stmt -> . IF ( condition ) { statements } ELSE { statements }
    (21) if_stmt -> . IF ( condition ) { statements }
    (18) cat_stmt -> . CAT ( expr )
    (19) print_stmt -> . PRINT ( expr )
    (9) assign -> . ID ATRIB expr
    }               shift and go to state 74
    FOR             shift and go to state 9
    IF              shift and go to state 11
    CAT             shift and go to state 12
    PRINT           shift and go to state 13
    ID              shift and go to state 10

    statement                      shift and go to state 14
    for_stmt                       shift and go to state 4
    if_stmt                        shift and go to state 5
    cat_stmt                       shift and go to state 6
    print_stmt                     shift and go to state 7
    assign                         shift and go to state 8

state 74

    (20) if_stmt -> IF ( condition ) { statements } ELSE { statements } .
    FOR             reduce using rule 20 (if_stmt -> IF ( condition ) { statements } ELSE { statements } .)
    IF              reduce using rule 20 (if_stmt -> IF ( condition ) { statements } ELSE { statements } .)
    CAT             reduce using rule 20 (if_stmt -> IF ( condition ) { statements } ELSE { statements } .)
    PRINT           reduce using rule 20 (if_stmt -> IF ( condition ) { statements } ELSE { statements } .)
    ID              reduce using rule 20 (if_stmt -> IF ( condition ) { statements } ELSE { statements } .)
    $end            reduce using rule 20 (if_stmt -> IF ( condition ) { statements } ELSE { statements } .)
    }               reduce using rule 20 (if_stmt -> IF ( condition ) { statements } ELSE { statements } .)
